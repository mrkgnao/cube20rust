#[macro_use]
extern crate lazy_static;
extern crate bitvec;
extern crate rand;

use rand::Rng;
use std::collections::HashMap;
use std::fmt;

/// Number of axes, I guess
pub const N_TWISTS: usize = 3;
/// 6 face moves + 3 slice moves = 9 axes
pub const N_MOVES: usize = 27;
/// Size of the subgroup of the automorphism group of a cube generated by
/// rotations and reflections
pub const N_SYMS: usize = 48;
pub const N_FACES: usize = 6;
pub const N_EDGES: usize = 12;
pub const N_CORNS: usize = 8;
pub const N_CUBIES: usize = 24; // = 12 * 2 = 8 * 3 :D

// ------------------------------------------------------------------------------------------------
// Edges
// ------------------------------------------------------------------------------------------------

#[derive(Debug, Clone, Copy, PartialEq, PartialOrd, Hash, Ord, Eq)]
/// A newtype wrapper over u8
pub struct Edge(pub u8);

/// invariants:
/// perm(from(ep, _)) == ep
/// orient(from(_, eo)) == eo
impl Edge {
    pub fn new(n: u8) -> Edge {
        debug_assert!(n <= 23 || n == INVALID, "invalid edge value {}", n);
        Self(n)
    }

    pub fn from(ep: EdgePerm, eo: EdgeOrient) -> Edge {
        Self::new(ep.0 * 2 + eo.0)
    }

    pub fn from_raws(ep: u8, eo: u8) -> Edge {
        Self::from(EdgePerm::new(ep), EdgeOrient::new(eo))
    }

    /// edge_flip
    pub fn flip(&self) -> Edge {
        Edge::new(self.0 ^ 1)
    }

    /// edge_perm
    pub fn perm(&self) -> EdgePerm {
        EdgePerm::new(self.0 >> 1)
    }

    /// edge_ori
    pub fn orient(&self) -> EdgeOrient {
        EdgeOrient::new(self.0 & 0b001)
    }

    pub fn add_orient(&self, orien: EdgeOrient) -> Edge {
        Edge::new(self.0 ^ orien.0)
    }

    pub fn add_orient_of(&self, take_orient_of: Edge) -> Edge {
        Edge::new(self.0 ^ take_orient_of.orient().0)
    }

    pub fn as_idx(&self) -> usize {
        self.0 as usize
    }
}

#[derive(Debug, Clone, Copy)]
/// A newtype wrapper over u8
pub struct EdgePerm(pub u8);

impl EdgePerm {
    pub fn new(n: u8) -> Self {
        debug_assert!(n <= 11, "bad edge perm {}", n);
        Self(n)
    }

    pub fn to_cubie(self) -> EdgeName {
        let x = self.0;
        match x {
            0 => EdgeName::UB,
            1 => EdgeName::UL,
            2 => EdgeName::UR,
            3 => EdgeName::UF,
            4 => EdgeName::BL,
            5 => EdgeName::BR,
            6 => EdgeName::FL,
            7 => EdgeName::FR,
            8 => EdgeName::DB,
            9 => EdgeName::DL,
            10 => EdgeName::DR,
            11 => EdgeName::DF,
            x => unreachable!("{}", x),
        }
    }
    pub fn as_idx(&self) -> usize {
        self.0 as usize
    }
}

#[derive(Debug, Clone, Copy)]
pub struct EdgeOrient(pub u8);

impl EdgeOrient {
    pub fn new(n: u8) -> Self {
        debug_assert!(n <= 1, "bad edge orient {}", n);
        Self(n)
    }
}

// ------------------------------------------------------------------------------------------------
// Corners
// ------------------------------------------------------------------------------------------------

#[derive(Debug, Clone, Copy, PartialOrd, PartialEq, Eq, Ord, Hash)]
/// A newtype wrapper over u8
pub struct Corn(pub u8);

impl Corn {
    pub fn new(n: u8) -> Corn {
        debug_assert!(n <= 23 || n == INVALID, "invalid corn value {}", n);
        Self(n)
    }

    pub fn from(cp: CornPerm, co: CornOrient) -> Corn {
        Self((co.0 * 8) + cp.0)
    }

    pub fn from_raws(cp: u8, co: u8) -> Corn {
        Self::from(CornPerm::new(cp), CornOrient::new(co))
    }

    pub fn perm(&self) -> CornPerm {
        CornPerm::new(self.0 & 7)
    }

    pub fn orient(&self) -> CornOrient {
        CornOrient::new(self.0 >> 3)
    }

    pub fn add_orient_of(&self, take_orient_of: Corn) -> Corn {
        Corn::new(MOD24[(self.0 + (take_orient_of.0 & 0b11000)) as usize])
    }

    pub fn sub_orient_of(&self, take_orient_of: Corn) -> Corn {
        // Corn::from_raws(self.perm().0, (3 - take_orient_of.orient().0) % 3)
        Corn::new(self.0 + CORN_ORIENT_NEG_STRIP[take_orient_of.as_idx()].0)
    }

    pub fn orient_inc(&self) -> Corn {
        CORN_ORIENT_INCR[self.as_idx()]
    }

    pub fn orient_dec(&self) -> Corn {
        CORN_ORIENT_DECR[self.as_idx()]
    }

    pub fn as_idx(&self) -> usize {
        self.0 as usize
    }
}

#[derive(Debug, Clone, Copy)]
/// A newtype wrapper over u8
pub struct CornPerm(pub u8);

impl CornPerm {
    pub fn new(n: u8) -> Self {
        debug_assert!(n <= 11, "bad corner perm: {}", n);
        Self(n)
    }

    pub fn to_cubie(self) -> CornName {
        let x = self.0;
        match x {
            0 => CornName::UBL,
            1 => CornName::UBR,
            2 => CornName::UFL,
            3 => CornName::UFR,
            4 => CornName::DBL,
            5 => CornName::DBR,
            6 => CornName::DFL,
            7 => CornName::DFR,
            _ => unreachable!(),
        }
    }
    pub fn as_idx(&self) -> usize {
        self.0 as usize
    }
}

#[derive(Debug, Clone, Copy)]
pub struct CornOrient(pub u8);

impl CornOrient {
    pub fn new(n: u8) -> Self {
        debug_assert!(n <= 2, "bad corner orient {}", n);
        Self(n)
    }
}

#[derive(Debug, Clone, PartialEq, PartialOrd, Ord, Hash, Eq)]
/// Cube
pub struct Cube {
    pub edges: [Edge; N_EDGES],
    pub corns: [Corn; N_CORNS],
}

lazy_static! {
    static ref CORN_ORIENT_TABLE: [(Corn, Corn, Corn); N_CUBIES] = {
        let mut ret = [(Corn::new(0), Corn::new(0), Corn::new(0)); N_CUBIES];
        for i in 0..N_CUBIES {
            let corn = Corn::new(i as u8);
            let perm = corn.perm();
            let orien = corn.orient();
            ret[i].0 = Corn::from_raws(perm.0, (orien.0 + 1) % 3);
            ret[i].1 = Corn::from_raws(perm.0, (orien.0 + 2) % 3);
            ret[i].2 = Corn::from_raws(0, (3 - orien.0) % 3);
        }
        ret
    };
    static ref CORN_ORIENT_INCR: [Corn; N_CUBIES] = {
        let mut ret = [Corn::new(0); N_CUBIES];
        for i in 0..N_CUBIES {
            ret[i] = CORN_ORIENT_TABLE[i].0;
        }
        ret
    };
    static ref CORN_ORIENT_DECR: [Corn; N_CUBIES] = {
        let mut ret = [Corn::new(0); N_CUBIES];
        for i in 0..N_CUBIES {
            ret[i] = CORN_ORIENT_TABLE[i].1;
        }
        ret
    };
    static ref CORN_ORIENT_NEG_STRIP: [Corn; N_CUBIES] = {
        let mut ret = [Corn::new(0); N_CUBIES];
        for i in 0..N_CUBIES {
            ret[i] = CORN_ORIENT_TABLE[i].2;
        }
        ret
    };
    static ref MOD24: [u8; 2 * N_CUBIES] = {
        let mut ret = [0; 2 * N_CUBIES];
        for i in 0..N_CUBIES {
            ret[i] = i as u8;
            ret[i + N_CUBIES] = i as u8;
        }
        ret
    };

    /// The identity cube
    static ref IDENTITY_CUBE: Cube = {
        let mut cube = Cube::ALL_ZEROS;
        for i in 0..8u8 {
            cube.corns[i as usize] = Corn::from_raws(i, 0);
        }
        for i in 0..12u8 {
            cube.edges[i as usize] = Edge::from_raws(i, 0);
        }
        cube
    };
}

pub const N_CANON_SEQ_STATES: usize = 5 * N_FACES / 2 + 1;
pub const CANON_SEQ_START: u64 = 0;

pub const INVALID: u8 = 99;

pub const ALL_MOVE_MASK: u64 = (1 << N_MOVES) - 1;

pub const FACES: [char; N_FACES] = ['U', 'F', 'R', 'D', 'B', 'L'];

/// STM faces
pub const MOVE_FACES: [char; N_FACES + 3] = ['U', 'F', 'R', 'D', 'B', 'L', 'I', 'J', 'K'];

pub const EDGE_TWIST_PERM: [[u8; 4]; N_FACES] = [
    [0, 2, 3, 1],
    [3, 7, 11, 6],
    [2, 5, 10, 7],
    [9, 11, 10, 8],
    [0, 4, 8, 5],
    [1, 6, 9, 4],
];

pub const CORN_TWIST_PERM: [[u8; 4]; N_FACES] = [
    [0, 1, 3, 2],
    [2, 3, 7, 6],
    [3, 1, 5, 7],
    [4, 6, 7, 5],
    [1, 0, 4, 5],
    [0, 2, 6, 4],
];

// Choice of orientation
pub const EDGE_CHANGE: [u8; N_FACES] = [0, 0, 1, 0, 0, 1];
// pub const EDGE_CHANGE: [u8; N_FACES] = [0, 1, 0, 0, 1, 0];

pub const CORN_CHANGE: [[u8; 4]; N_FACES] = [
    [0, 0, 0, 0],
    [1, 2, 1, 2],
    [1, 2, 1, 2],
    [0, 0, 0, 0],
    [1, 2, 1, 2],
    [1, 2, 1, 2],
];

pub fn conv_face(f: Face) -> u8 {
    match f {
        Face::U => 0,
        Face::F => 1,
        Face::R => 2,
        Face::D => 3,
        Face::B => 4,
        Face::L => 5,
    }
}

pub fn conv_moveface(f: MoveFace) -> u8 {
    match f {
        MoveFace::U => 0,
        MoveFace::F => 1,
        MoveFace::R => 2,
        MoveFace::D => 3,
        MoveFace::B => 4,
        MoveFace::L => 5,
        MoveFace::I => 6,
        MoveFace::J => 7,
        MoveFace::K => 8,
    }
}

pub fn conv_cubie(fs: &[Face]) -> u32 {
    let mut v: u32 = 1;

    for &f in fs {
        // right shift v by 1 in base 6 and add f
        v = v * 6 + conv_face(f) as u32;

        // v >= 2000 in base 6
        if v >= 2 * 6 * 6 * 6 {
            panic!("cubie too large");
        }
    }

    v
}

pub fn conv_edge(fs: [Face; 2]) -> Option<Edge> {
    let c = conv_cubie(&fs);
    if c < 6 * 6 || c >= 2 * 6 * 6 {
        panic!("bad edge");
    }
    let edge = EDGE_CUBIE_LUT[(c - 6 * 6) as usize];
    if edge.is_none() || c as usize >= N_CUBIES {
        None
    } else {
        edge
    }
}

pub fn conv_corn(fs: [Face; 3]) -> Option<Corn> {
    let c = conv_cubie(&fs);
    if c < 6 * 6 * 6 || c >= 2 * 6 * 6 * 6 {
        panic!("bad corn");
    }
    let corn = CORN_CUBIE_LUT[(c - 6 * 6 * 6) as usize];
    if corn.is_none() || c as usize >= N_CUBIES {
        None
    } else {
        corn
    }
}

pub fn conv_corn_to_facemap(p: &[Face], a: &mut [u8]) {
    for i in 0..3 {
        let f = conv_face(p[i]);
        a[i] = f;
        a[i + 3] = (f + 3) % (N_FACES as u8);
    }
}

#[derive(Debug, Copy, Clone)]
pub enum Face {
    U,
    F,
    R,
    D,
    B,
    L,
}

#[derive(Debug, Copy, Clone)]
pub enum MoveFace {
    U,
    F,
    R,
    D,
    B,
    L,
    I,
    J,
    K,
}

lazy_static! {
    static ref SINGMASTER_EDGES: [[Face; 2]; 24] = {
        use Face::*;
        [
            [U, B],
            [B, U],
            [U, L],
            [L, U],
            [U, R],
            [R, U],
            [U, F],
            [F, U],
            [L, B],
            [B, L],
            [R, B],
            [B, R],
            [L, F],
            [F, L],
            [R, F],
            [F, R],
            [D, B],
            [B, D],
            [D, L],
            [L, D],
            [D, R],
            [R, D],
            [D, F],
            [F, D],
        ]
    };
    static ref SINGMASTER_CORNS: [[Face; 3]; 48] = {
        use Face::*;
        [
            [U, B, L],
            [U, R, B],
            [U, L, F],
            [U, F, R],
            [D, L, B],
            [D, B, R],
            [D, F, L],
            [D, R, F],
            [L, U, B],
            [B, U, R],
            [F, U, L],
            [R, U, F],
            [B, D, L],
            [R, D, B],
            [L, D, F],
            [F, D, R],
            [B, L, U],
            [R, B, U],
            [L, F, U],
            [F, R, U],
            [L, B, D],
            [B, R, D],
            [F, L, D],
            [R, F, D],
            [U, L, B],
            [U, B, R],
            [U, F, L],
            [U, R, F],
            [D, B, L],
            [D, R, B],
            [D, L, F],
            [D, F, R],
            [L, B, U],
            [B, R, U],
            [F, L, U],
            [R, F, U],
            [B, L, D],
            [R, B, D],
            [L, F, D],
            [F, R, D],
            [B, U, L],
            [R, U, B],
            [L, U, F],
            [F, U, R],
            [L, D, B],
            [B, D, R],
            [F, D, L],
            [R, D, F],
        ]
    };
    static ref AXIS_PERMUTE_MAP: [[Face; 3]; 6] = {
        use Face::*;
        [
            [U, F, R],
            [U, R, F],
            [F, R, U],
            [F, U, R],
            [R, U, F],
            [R, F, U],
        ]
    };
    static ref AXIS_NEGATE_MAP: [[Face; 3]; 8] = {
        use Face::*;
        [
            [U, F, R],
            [U, F, L],
            [U, B, L],
            [U, B, R],
            [D, B, R],
            [D, B, L],
            [D, F, L],
            [D, F, R],
        ]
    };
    static ref FACE_MAP: [[u8; N_FACES]; N_SYMS] = {
        let mut ret = [[0; N_FACES]; N_SYMS];

        for i in 0..6 {
            conv_corn_to_facemap(&AXIS_PERMUTE_MAP[i], &mut ret[8 * i]);
        }

        for i in 0..8 {
            conv_corn_to_facemap(&AXIS_NEGATE_MAP[i], &mut ret[i]);
        }

        for i in 1..6 {
            for j in 1..8 {
                for k in 0..6 {
                    ret[8 * i + j][k] = ret[j][ret[8* i][k] as usize];
                }
            }
        }

        ret
    };
    static ref FACE_TO_SYM: [u8; N_FACES * N_FACES * N_FACES] = {
        let mut ret = [0; N_FACES * N_FACES * N_FACES];
        for i in 0..N_SYMS {
            let v: u8 = FACE_MAP[i][0] * 36 + FACE_MAP[i][1] * 6 + FACE_MAP[i][2];
            ret[v as usize] = i as u8;
        }
        ret
    };
    static ref MULT_SYM: [[u8; N_SYMS]; N_SYMS] = {
        let mut tfaces = [0; 6];
        let mut ret = [[0; N_SYMS]; N_SYMS];
        for i in 0..N_SYMS {
            for j in 0..N_SYMS {
                for k in 0..6 {
                    tfaces[k] = FACE_MAP[j][FACE_MAP[i][k] as usize];
                }
                let v = tfaces[0] * 36 + tfaces[1] * 6 + tfaces[2];
                ret[i][j] = FACE_TO_SYM[v as usize];
            }
        }
        ret
    };
    static ref INVERT_SYM: [Sym; N_SYMS] = {
        let mut ret = [Sym::new(0); N_SYMS];
        for i in 0..N_SYMS {
            for j in 0..N_SYMS {
                if MULT_SYM[i][j] == 0 {
                    ret[i] = Sym::new(j as u8);
                }
            }
        }
        ret
    };
    static ref MOVE_MAP: [[Move; N_MOVES]; N_SYMS] = {
        let mut ret = [[Move::new(0); N_MOVES]; N_SYMS];
        for m in 0..N_SYMS {
            let is_neg: i32 = (m as i32 ^ (m as i32 >> 3)) & 1;
            for f in 0..N_FACES {
                for t in 0..N_TWISTS {
                    if is_neg != 0 {
                        ret[m][f * N_TWISTS + t] =
                            Move::new(FACE_MAP[m][f] * N_TWISTS as u8 + ((N_TWISTS - t - 1) as u8));
                    } else {
                        ret[m][f * N_TWISTS + t] =
                            Move::new(FACE_MAP[m][f] * N_TWISTS as u8 + (t as u8));
                    }

                    if f < 3 {
                        if FACE_MAP[m][f] < 3 {
                            ret[m][(f + N_FACES) * N_TWISTS + t] =
                                Move::new((N_FACES * N_TWISTS) as u8 + ret[m][f * N_TWISTS + t].0);
                        } else {
                            ret[m][(f + N_FACES) * N_TWISTS + N_TWISTS - t - 1] =
                                Move::new(3 * N_TWISTS as u8 + ret[m][f * N_TWISTS + t].0);
                        }
                    }
                }
            }
        }
        ret
    };
    /// Edge-cubie lookup table
    static ref EDGE_CUBIE_LUT: [Option<Edge>; N_CUBIES * N_CUBIES] = {
        let mut ret = [None; N_CUBIES * N_CUBIES];
        for i in 0..N_CUBIES {
            ret[conv_cubie(&SINGMASTER_EDGES[i]) as usize - 6 * 6] = Some(Edge::new(i as u8));
        }
        ret
    };
    static ref CORN_CUBIE_LUT: [Option<Corn>; N_CUBIES * N_CUBIES * N_CUBIES] = {
        let mut ret = [None; N_CUBIES * N_CUBIES * N_CUBIES];
        for i in 0..N_CUBIES {
            // Move the mod24 into the construction of this table rather than
            // in `ROT_CORN`.
            ret[conv_cubie(&SINGMASTER_CORNS[i]) as usize - 6 * 6 * 6]
                = Some(Corn::new(MOD24[i]));
            ret[conv_cubie(&SINGMASTER_CORNS[N_CUBIES + i]) as usize - 6 * 6 * 6]
                = Some(Corn::new(MOD24[N_CUBIES + i]));
        }
        ret
    };
    static ref ROT_EDGE: [[Edge; N_CUBIES]; N_SYMS] = {
        let mut ret = [[Edge::new(0); N_CUBIES]; N_SYMS];
        for m in 0..N_SYMS {
            for c in 0..N_CUBIES {
                let mut v = 0;
                for i in 0..2 {
                    v = 6 * v + FACE_MAP[m][conv_face(SINGMASTER_EDGES[c][i]) as usize];
                }
                ret[m][c] = EDGE_CUBIE_LUT[v as usize].unwrap();
            }
        }
        ret
    };
    static ref ROT_CORN: [[Corn; N_CUBIES]; N_SYMS] = {
        let mut ret = [[Corn::new(0); N_CUBIES]; N_SYMS];
        for m in 0..N_SYMS {
            for c in 0..N_CUBIES {
                let mut v = 0;
                for i in 0..3 {
                    v = 6 * v + FACE_MAP[m][conv_face(SINGMASTER_CORNS[c][i]) as usize];
                }
                ret[m][c] = CORN_CUBIE_LUT[v as usize].unwrap();
            }
        }
        ret
    };
}

lazy_static! {
    static ref TRANSITION_TABLE: [[(Edge, Corn); N_CUBIES]; N_MOVES] = {
        let mut ret = [[(Edge::new(0), Corn::new(0)); N_CUBIES]; N_MOVES];
        for m in 0..N_MOVES {
            for c in 0..N_CUBIES {
                ret[m][c] = (Edge::new(c as u8), Corn::new(c as u8));
            }
        }

        for face in 0..N_FACES {
            for turn in 0..3 {
                let m: usize = face * N_TWISTS + turn;
                let is_quarter: bool = turn == 0 || turn == 2;
                let perm_inc = turn + 1;

                for i in 0..4 {
                    let new_i = (i + perm_inc) % 4;
                    for orien in 0..2 {
                        let mut new_orien = orien;
                        if is_quarter {
                            new_orien ^= EDGE_CHANGE[face];
                        }
                        let old_c = Edge::from_raws(EDGE_TWIST_PERM[face][i], orien).as_idx();
                        let new_c = Edge::from_raws(EDGE_TWIST_PERM[face][new_i], new_orien);
                        ret[m][old_c].0 = new_c;
                    }

                    for orien in 0..3 {
                        let mut new_orien = orien;
                        if is_quarter {
                            new_orien = (CORN_CHANGE[face][i] + new_orien) % 3;
                        }
                        let old_c = Corn::from_raws(CORN_TWIST_PERM[face][i], orien).as_idx();
                        let new_c = Corn::from_raws(CORN_TWIST_PERM[face][new_i], new_orien);
                        ret[m][old_c].1 = new_c;
                    }
                }
            }
        }

        for face in 0..3 {
            for turn in 0..N_TWISTS {
                let m1 = face * N_TWISTS + turn;
                let m2 = (face + 3) * N_TWISTS + (N_TWISTS - 1 - turn);
                let m3 = m1 + N_FACES * N_TWISTS;

                for c in 0..N_CUBIES {
                    if ret[m1][c].0 != Edge::new(c as u8) {
                        ret[m3][c].0 = ret[m1][c].0;
                    }
                    if ret[m2][c].0 != Edge::new(c as u8) {
                        ret[m3][c].0 = ret[m2][c].0;
                    }

                    if ret[m1][c].1 != Corn::new(c as u8) {
                        ret[m3][c].1 = ret[m1][c].1;
                    }
                    if ret[m2][c].1 != Corn::new(c as u8) {
                        ret[m3][c].1 = ret[m2][c].1;
                    }
                }
            }
        }

        ret
    };
    static ref EDGE_TRANS: [[Edge; N_CUBIES]; N_MOVES] = {
        let mut ret = [[Edge::new(0); N_CUBIES]; N_MOVES];
        for m in 0..N_MOVES {
            for c in 0..N_CUBIES {
                ret[m][c] = TRANSITION_TABLE[m][c].0;
            }
        }
        ret
    };
    static ref CORN_TRANS: [[Corn; N_CUBIES]; N_MOVES] = {
        let mut ret = [[Corn::new(0); N_CUBIES]; N_MOVES];
        for m in 0..N_MOVES {
            for c in 0..N_CUBIES {
                ret[m][c] = TRANSITION_TABLE[m][c].1;
            }
        }
        ret
    };
}

#[derive(Debug, Clone)]
pub enum EdgeName {
    UB,
    UL,
    UR,
    UF,
    BL,
    BR,
    FL,
    FR,
    DB,
    DL,
    DR,
    DF,
}

#[derive(Debug, Clone)]
pub enum CornName {
    UBL,
    UBR,
    UFL,
    UFR,
    DBL,
    DBR,
    DFL,
    DFR,
}

impl Cube {
    const ALL_ZEROS: Cube = Cube {
        corns: [Corn(0); 8],
        edges: [Edge(0); 12],
    };

    pub fn new() -> Self {
        IDENTITY_CUBE.clone()
    }

    pub fn scramble_vec(&mut self, scram: &Vec<Move>) {
        for mov in scram.iter() {
            self.apply_move(*mov);
        }
    }

    // apply a corrective y before scrambling
    pub fn scramble(&mut self, scram: &str) {
        let movs = scram.split_whitespace();
        for mov_ in movs.into_iter() {
            let mov = match mov_ {
                "U"  => 0,
                "U2" => 1,
                "U'" => 2,
                // "F"  => 3,
                // "F2" => 4,
                // "F'" => 5,
                // "R"  => 6,
                // "R2" => 7,
                // "R'" => 8,
                "F"  => 6,
                "F2" => 7,
                "F'" => 8,
                "R"  => 12,
                "R2" => 13,
                "R'" => 14,
                "D"  => 9,
                "D2" => 10,
                "D'" => 11,
                // "B"  => 12,
                // "B2" => 13,
                // "B'" => 14,
                "B"  => 15,
                "B2" => 16,
                "B'" => 17,
                // "L"  => 15,
                // "L2" => 16,
                // "L'" => 17,
                "L"  => 3,
                "L2" => 4,
                "L'" => 5,
                _ => panic!("bad move, cannot scramble"),
            };
            self.apply_move(Move::new(mov));
        }
    }

    pub fn randomise(&mut self) {
        let parity = 0;
        for i in 0..7 {
            let j = i + rand::thread_rng().gen_range(0, 8 - i);
            if i != j {
                let temp = self.corns[i];
                self.corns[i] = self.corns[j];
                self.corns[j] = temp;
            }
        }
        for i in 0..11 {
            let j = i + rand::thread_rng().gen_range(0, 12 - i);
            if i != j {
                let temp = self.edges[i];
                self.edges[i] = self.edges[j];
                self.edges[j] = temp;
            }
        }
        if (parity & 1) != 0 {
            let temp = self.edges[10];
            self.edges[10] = self.edges[11];
            self.edges[11] = temp;
        }

        let mut s = 24;

        for i in 0..7 {
            let a = rand::thread_rng().gen_range(0, 3);
            s -= a;
            self.corns[i] = Corn::from(self.corns[i].perm(), CornOrient::new(a));
        }

        self.corns[7] = Corn::from(self.corns[7].perm(), CornOrient::new(s % 3));

        let mut s = 0;
        for i in 0..11 {
            let a = rand::thread_rng().gen_range(0, 2);
            self.edges[i] = self.edges[i].add_orient(EdgeOrient::new(a));
            s ^= a;
        }
        self.edges[11] = Edge::new(self.edges[11].0 ^ s);
    }

    pub fn apply_move(&mut self, mov: Move) {
        let m = mov.as_idx();
        for i in 0..8 {
            self.corns[i] = CORN_TRANS[m][self.corns[i].0 as usize];
        }
        for i in 0..12 {
            self.edges[i] = EDGE_TRANS[m][self.edges[i].0 as usize];
        }
    }

    pub fn edges_rot2(&mut self, a: usize, b: usize) {
        let temp: Edge = self.edges[a];
        self.edges[a] = self.edges[b];
        self.edges[b] = temp;
    }

    pub fn edges_rot4(&mut self, a: usize, b: usize, c: usize, d: usize) {
        let temp: Edge = self.edges[d];
        self.edges[d] = self.edges[c];
        self.edges[c] = self.edges[b];
        self.edges[b] = self.edges[a];
        self.edges[a] = temp;
    }

    pub fn corns_rot4(&mut self, a: usize, b: usize, c: usize, d: usize) {
        let temp: Corn = self.corns[d];
        self.corns[d] = self.corns[c];
        self.corns[c] = self.corns[b];
        self.corns[b] = self.corns[a];
        self.corns[a] = temp;
    }

    pub fn corns_rot2(&mut self, a: usize, b: usize) {
        let temp: Corn = self.corns[a];
        self.corns[a] = self.corns[b];
        self.corns[b] = temp;
    }

    pub fn edges_rot22(&mut self, a: usize, b: usize, c: usize, d: usize) {
        self.edges_rot2(a, c);
        self.edges_rot2(b, d);
    }
    pub fn corns_rot22(&mut self, a: usize, b: usize, c: usize, d: usize) {
        self.corns_rot2(a, c);
        self.corns_rot2(b, d);
    }

    pub fn edges_4flip(&mut self, a: usize, b: usize, c: usize, d: usize) {
        let temp: Edge = self.edges[d];
        self.edges[d] = self.edges[c].flip();
        self.edges[c] = self.edges[b].flip();
        self.edges[b] = self.edges[a].flip();
        self.edges[a] = temp.flip();
    }

    pub fn corns_4flip(&mut self, a: usize, b: usize, c: usize, d: usize) {
        let temp: Corn = self.corns[d];
        self.corns[d] = self.corns[c].orient_inc();
        self.corns[c] = self.corns[b].orient_dec();
        self.corns[b] = self.corns[a].orient_inc();
        self.corns[a] = temp.orient_dec();
    }

    /// Apply a move considering the repr as being the slot-to-perm (position-to-cubie) repr.
    pub fn apply_sp_move(&mut self, mov: Move) {
        let m = mov.as_idx();

        match m {
            0 => {
                self.edges_rot4(0, 2, 3, 1);
                self.corns_rot4(0, 1, 3, 2);
            }
            1 => {
                self.edges_rot22(0, 2, 3, 1);
                self.corns_rot22(0, 1, 3, 2);
            }
            2 => {
                self.edges_rot4(1, 3, 2, 0);
                self.corns_rot4(2, 3, 1, 0);
            }
            3 => {
                self.edges_rot4(3, 7, 11, 6);
                self.corns_4flip(3, 7, 6, 2);
            }
            4 => {
                self.edges_rot22(3, 7, 11, 6);
                self.corns_rot22(2, 3, 7, 6);
            }
            5 => {
                self.edges_rot4(6, 11, 7, 3);
                self.corns_4flip(3, 2, 6, 7);
            }
            6 => {
                self.edges_4flip(2, 5, 10, 7);
                self.corns_4flip(1, 5, 7, 3);
            }
            7 => {
                self.edges_rot22(2, 5, 10, 7);
                self.corns_rot22(3, 1, 5, 7);
            }
            8 => {
                self.edges_4flip(7, 10, 5, 2);
                self.corns_4flip(1, 3, 7, 5);
            }
            9 => {
                self.edges_rot4(9, 11, 10, 8);
                self.corns_rot4(4, 6, 7, 5);
            }
            10 => {
                self.edges_rot22(9, 11, 10, 8);
                self.corns_rot22(4, 6, 7, 5);
            }
            11 => {
                self.edges_rot4(8, 10, 11, 9);
                self.corns_rot4(5, 7, 6, 4);
            }
            12 => {
                self.edges_rot4(0, 4, 8, 5);
                self.corns_4flip(0, 4, 5, 1);
            }
            13 => {
                self.edges_rot22(0, 4, 8, 5);
                self.corns_rot22(1, 0, 4, 5);
            }
            14 => {
                self.edges_rot4(5, 8, 4, 0);
                self.corns_4flip(0, 1, 5, 4);
            }
            15 => {
                self.edges_4flip(1, 6, 9, 4);
                self.corns_4flip(2, 6, 4, 0);
            }
            16 => {
                self.edges_rot22(1, 6, 9, 4);
                self.corns_rot22(0, 2, 6, 4);
            }
            17 => {
                self.edges_4flip(4, 9, 6, 1);
                self.corns_4flip(2, 0, 4, 6);
            }
            18 => {
                self.edges_rot4(0, 2, 3, 1);
                self.corns_rot4(0, 1, 3, 2);
                self.edges_rot4(8, 10, 11, 9);
                self.corns_rot4(5, 7, 6, 4);
            }
            19 => {
                self.edges_rot22(0, 2, 3, 1);
                self.corns_rot22(0, 1, 3, 2);
                self.edges_rot22(9, 11, 10, 8);
                self.corns_rot22(4, 6, 7, 5);
            }
            20 => {
                self.edges_rot4(1, 3, 2, 0);
                self.corns_rot4(2, 3, 1, 0);
                self.edges_rot4(9, 11, 10, 8);
                self.corns_rot4(4, 6, 7, 5);
            }
            21 => {
                self.edges_rot4(3, 7, 11, 6);
                self.corns_4flip(3, 7, 6, 2);
                self.edges_rot4(5, 8, 4, 0);
                self.corns_4flip(0, 1, 5, 4);
            }
            22 => {
                self.edges_rot22(3, 7, 11, 6);
                self.corns_rot22(2, 3, 7, 6);
                self.edges_rot22(0, 4, 8, 5);
                self.corns_rot22(1, 0, 4, 5);
            }
            23 => {
                self.edges_rot4(6, 11, 7, 3);
                self.corns_4flip(3, 2, 6, 7);
                self.edges_rot4(0, 4, 8, 5);
                self.corns_4flip(0, 4, 5, 1);
            }
            24 => {
                self.edges_4flip(2, 5, 10, 7);
                self.corns_4flip(1, 5, 7, 3);
                self.edges_4flip(4, 9, 6, 1);
                self.corns_4flip(2, 0, 4, 6);
            }
            25 => {
                self.edges_rot22(2, 5, 10, 7);
                self.corns_rot22(3, 1, 5, 7);
                self.edges_rot22(1, 6, 9, 4);
                self.corns_rot22(0, 2, 6, 4);
            }
            26 => {
                self.edges_4flip(7, 10, 5, 2);
                self.corns_4flip(1, 3, 7, 5);
                self.edges_4flip(1, 6, 9, 4);
                self.corns_4flip(2, 6, 4, 0);
            }
            _ => unreachable!(),
        }
    }

    pub fn invert_into(&self, dest: &mut Self) {
        for i in 0..8 {
            let cval = self.corns[i];
            dest.corns[cval.perm().as_idx()] = Corn::new(i as u8).sub_orient_of(cval);
        }
        for i in 0..12 {
            let eval = self.edges[i];
            dest.edges[eval.perm().as_idx()] = Edge::from(EdgePerm::new(i as u8), eval.orient());
        }
    }

    pub fn from_inverse(&self) -> Self {
        let mut ret = Self::ALL_ZEROS;
        self.invert_into(&mut ret);
        ret
    }

    pub fn remap_into(&self, m: Sym, dest: &mut Self) {
        let mp = INVERT_SYM[m.as_idx()];
        for i in 0..8usize {
            let c1 = ROT_CORN[mp.as_idx()][i];
            let c2 = self.corns[c1.perm().as_idx()].add_orient_of(c1);
            let c3 = ROT_CORN[m.as_idx()][c2.as_idx()];
            dest.corns[i] = c3;
        }
        for i in 0..12usize {
            let e1 = ROT_EDGE[mp.as_idx()][i * 2];
            let e2 = self.edges[e1.perm().as_idx()].add_orient_of(e1);
            let e3 = ROT_EDGE[m.as_idx()][e2.as_idx()];
            dest.edges[i] = e3;
        }
    }

    pub fn canon_into_48_aux(&self, dest: &mut Self) {
        'outer: for m_ in 1..N_SYMS {
            let mp = INVERT_SYM[m_];
            let mut is_less = false;
            for i in 0..8 {
                let c1 = ROT_CORN[mp.0 as usize][i];
                let c2 = self.corns[c1.perm().0 as usize].add_orient_of(c1);
                let t = ROT_CORN[m_][c2.0 as usize].0;
                if is_less || t < dest.corns[i].0 {
                    dest.corns[i] = Corn::new(t);
                    is_less = true;
                } else if t > dest.corns[i].0 {
                    continue 'outer;
                }
            }

            for i in 0..12 {
                let e1 = ROT_EDGE[mp.0 as usize][i * 2];
                let e2 = self.edges[e1.perm().0 as usize].add_orient_of(e1);
                let t = ROT_EDGE[m_][e2.0 as usize].0;
                if is_less || t < dest.edges[i].0 {
                    dest.edges[i] = Edge::new(t);
                    is_less = true;
                } else if t > dest.edges[i].0 {
                    continue 'outer; // why not return?
                }
            }
        }
    }

    pub fn canon_into_48(&self, dest: &mut Self) {
        dest.clone_from(&self);
        self.canon_into_48_aux(dest);
    }

    pub fn canon_into_96(&self, dest: &mut Self) {
        let mut cpi = Self::ALL_ZEROS;
        self.invert_into(&mut cpi);
        let vcorns = Vec::from(&self.corns[..]);
        let wcorns = Vec::from(&cpi.corns[..]);
        let vedges = Vec::from(&self.edges[..]);
        let wedges = Vec::from(&cpi.edges[..]);
        // Lex search because rust does not allow us to compare arrays directly
        if vcorns < wcorns || (vcorns == wcorns && vedges < wedges) {
            dest.clone_from(&self);
        } else {
            dest.clone_from(&cpi);
        }
        self.canon_into_48_aux(dest);
        cpi.canon_into_48_aux(dest);
    }

    pub fn mul_sp(a: &Self, b: &Self, r: &mut Self) {
        Self::mul(b, a, r);
    }

    pub fn mul(a: &Self, b: &Self, r: &mut Self) {
        for i in 0..8 {
            let cc: Corn = a.corns[i];
            r.corns[i] = b.corns[cc.perm().as_idx()].add_orient_of(cc);
        }
        for i in 0..12 {
            let ee: Edge = a.edges[i];
            r.edges[i] = b.edges[ee.perm().as_idx()].add_orient_of(ee);
        }
    }
}

lazy_static! {
    static ref INVERT_MOVE: [Move; N_MOVES] = {
        let mut ret = [Move::new(0); N_MOVES];
        for i in 0..N_MOVES {
            ret[i] = Move::new((N_TWISTS * (i / N_TWISTS) + (N_MOVES - i - 1) % N_TWISTS) as u8);
        }
        ret
    };
}

#[derive(Debug, Clone, Copy)]
pub struct Sym(pub u8);

impl Sym {
    pub fn new(n: u8) -> Self {
        debug_assert!(n < N_SYMS as u8, "bad sym {}", n);
        Self(n)
    }

    pub fn as_idx(&self) -> usize {
        self.0 as usize
    }
}

#[derive(Debug, Clone, Copy)]
pub struct Move(pub u8);

impl Move {
    pub fn new(n: u8) -> Self {
        debug_assert!(n <= 27, "bad move {}", n);
        Self(n)
    }
    pub fn from_moveface(f: MoveFace) -> Self {
        Self(match f {
            MoveFace::U => 0,
            MoveFace::F => 3,
            MoveFace::R => 6,
            MoveFace::D => 9,
            MoveFace::B => 12,
            MoveFace::L => 15,
            MoveFace::I => 18,
            MoveFace::J => 21,
            MoveFace::K => 24,
        })
    }
    pub fn invert(&self) -> Move {
        INVERT_MOVE[self.as_idx()]
    }
    pub fn as_idx(&self) -> usize {
        self.0 as usize
    }
    pub fn random() -> Move {
        Move::new(rand::thread_rng().gen_range(0, N_MOVES as u8))
    }
}

#[derive(Debug, Clone)]
pub struct MoveSeq(Vec<Move>);

impl MoveSeq {
    pub fn new() -> Self {
        Self(Vec::new())
    }
    pub fn push(&mut self, m: Move) {
        self.0.push(m)
    }
    pub fn len(&self) -> usize {
        self.0.len()
    }
    pub fn invert(&self) -> Self {
        let len: usize = self.0.len();
        let mut v = vec![Move(0); len];

        for i in 0..len {
            v[len - i - 1] = self.0[i].invert();
        }

        MoveSeq(v)
    }

    pub fn random(n: usize) -> Self {
        let mut v = Vec::new(); // with_capacity(n);
        for _ in 0..n {
            v.push(Move::random());
        }
        Self(v)
    }

    pub fn get(&self, n: usize) -> Move {
        self.0[n]
    }
}

lazy_static! {
    static ref CANON_SEQ_MASK: [u64; N_CANON_SEQ_STATES] = _CANON_SEQ_AND_MASK.1;
    static ref CANON_SEQ: [[u8; N_MOVES]; N_CANON_SEQ_STATES] = _CANON_SEQ_AND_MASK.0;
    static ref _CANON_SEQ_AND_MASK: (
        [[u8; N_MOVES]; N_CANON_SEQ_STATES],
        [u64; N_CANON_SEQ_STATES]
    ) = {
        let mut cseq = [[0; N_MOVES]; N_CANON_SEQ_STATES];
        let mut cmask = [0; N_CANON_SEQ_STATES];
        for s in 0..N_CANON_SEQ_STATES {
            cmask[s] = (1u64 << N_MOVES) - 1;
        }
        for s in 0..N_CANON_SEQ_STATES {
            let mut axis = (s as i32 - 1) / 5;
            let ss = (s as i32 - 1) % 5;
            if s == 0 {
                axis = -1;
            }
            for mv in 0..N_MOVES as i32 {
                let mvax = (mv / N_TWISTS as i32) % 3;
                if (mvax == axis && ((mv < 9) || (mv >= 18) || (ss >= 3) || (ss + (mv % 3) == 2)))
                    || (ss == 3
                        && ((mvax as i32) < axis)
                        && (mv >= 18)
                        && (mv % N_TWISTS as i32 == 1))
                {
                    cseq[s][mv as usize] = INVALID;
                    cmask[s] &= !(1u64 << mv);
                } else {
                    if mv < 9 {
                        cseq[s][mv as usize] = (1 + 5 * mvax + mv % 3) as u8;
                    } else if mv >= 18 && mv % 3 == 1 {
                        cseq[s][mv as usize] = (1 + 5 * mvax + 3) as u8;
                    } else {
                        cseq[s][mv as usize] = (1 + 5 * mvax + 4) as u8;
                    }
                }
            }
        }
        (cseq, cmask)
    };
}

#[inline]
pub fn next_canon_seq(cs: u64, mv: usize) -> u8 {
    CANON_SEQ[cs as usize][mv]
}

#[inline]
pub fn canon_seq_mask(cs: u64) -> u64 {
    CANON_SEQ_MASK[cs as usize]
}

pub fn assert_cubes_eq_msg(cp1: &Cube, cp2: &Cube, msg: &str) {
    if cp1.corns == cp2.corns && cp1.edges == cp2.edges {
        return;
    }

    println!("\n{}, differences: ", msg);

    for i in 0..8 {
        // if cp1.corns[i] != cp2.corns[i] {
        println!("corn {:2}: {:2} {:2}", i, cp1.corns[i], cp2.corns[i]);
        // }
    }

    for i in 0..12 {
        if cp1.edges[i] != cp2.edges[i] {
            println!("edge {:2}: {:2} {:2}", i, cp1.edges[i], cp2.edges[i]);
        }
    }

    panic!("not equal");
}

pub fn assert_cubes_eq(cp1: &Cube, cp2: &Cube) {
    assert_cubes_eq_msg(cp1, cp2, "some msg")
}

#[test]
pub fn test_expected_memory_sizes() {
    assert_eq!(std::mem::size_of::<Cube>(), 20);
}

#[test]
pub fn test_cube_initialisation() {
    let cp = Cube::new();

    for i in 0..8 {
        assert_eq!(cp.corns[i], IDENTITY_CUBE.corns[i]);
    }

    for i in 0..12 {
        assert_eq!(cp.edges[i], IDENTITY_CUBE.edges[i]);
    }
}

#[test]
pub fn test_up_down_preserved() {
    for i in 0..16 {
        assert_eq!(FACE_MAP[i][0] % 3, 0);
    }
}

#[test]
pub fn test_forward_backward_repr_inverse() {
    let mut cp = Cube::new();

    for i in 0..N_MOVES as u8 {
        cp.apply_move(Move::new(i));
        cp.apply_sp_move(Move::new(i));
        println!("testing {}", i);
        assert_cubes_eq(&cp, &IDENTITY_CUBE);
    }
}

#[test]
pub fn test_orders_of_basic_generators_forward() {
    let mut cp = Cube::new();
    for i in 0..N_FACES as u8 {
        for j in 1..=4 {
            cp.apply_move(Move::new(i * N_TWISTS as u8));
            println!("cp after {} moves of type {}: {:?}", j, i, cp);
        }
        assert_cubes_eq(&cp, &IDENTITY_CUBE);
        println!("");
    }
}

#[test]
pub fn test_orders_of_basic_generators_backward() {
    let mut cp = Cube::new();
    for i in 0..N_FACES as u8 {
        for j in 1..=4 {
            cp.apply_sp_move(Move::new(i * N_TWISTS as u8));
            println!("cp after {} moves of type {}: {:?}", j, i, cp);
        }
        assert_cubes_eq(&cp, &IDENTITY_CUBE);
    }
}

#[test]
pub fn test_invert_random_cubes() {
    let mut c = Cube::new();
    let mut c2 = Cube::new();
    let mut c3 = Cube::new();

    for i in 1..=100 {
        println!("cube #{}", i);
        c.randomise();
        println!("{}", c);
        c.invert_into(&mut c2);
        println!("{}", c2);
        c2.invert_into(&mut c3);
        println!("{}", c3);
        assert_cubes_eq(&c, &c3);
    }
}

#[test]
pub fn test_invert_random_moveseqs() {
    for i in 1..=100 {
        println!("cube #{}", i);

        let moveseq_size = 10;
        let ms = MoveSeq::random(moveseq_size);
        let msi = ms.invert();

        let mut cp = Cube::new();
        let mut cpi = Cube::new();

        for k in 0..moveseq_size {
            cp.apply_move(ms.get(k));
            cpi.apply_move(msi.get(k));
        }

        let cpi2 = Cube::from_inverse(&cp);
        assert_cubes_eq(&cpi, &cpi2);
    }
}

#[test]
pub fn test_group_multiplication_forward() {
    let mut a = Cube::new();
    let mut b = Cube::new();
    let mut c = Cube::new();
    let mut r = Cube::new();

    let m = MoveSeq::random(10);
    let n = MoveSeq::random(10);

    for k in 0..m.len() {
        a.apply_move(m.get(k));
        c.apply_move(m.get(k));
    }

    for k in 0..n.len() {
        b.apply_move(n.get(k));
        c.apply_move(n.get(k));
    }

    Cube::mul(&a, &b, &mut r);

    assert_cubes_eq(&r, &c);
}

#[test]
pub fn test_group_multiplication_backward() {
    let mut a = Cube::new();
    let mut b = Cube::new();
    let mut c = Cube::new();
    let mut r = Cube::new();

    let m = MoveSeq::random(10);
    let n = MoveSeq::random(10);

    for k in 0..m.len() {
        a.apply_sp_move(m.get(k));
        c.apply_sp_move(m.get(k));
    }

    for k in 0..n.len() {
        b.apply_sp_move(n.get(k));
        c.apply_sp_move(n.get(k));
    }

    Cube::mul_sp(&a, &b, &mut r);

    assert_cubes_eq(&r, &c);
}

#[test]
pub fn test_remap() {
    for _ in 1..=100 {
        let mut ms = MoveSeq::new();
        let m = rand::thread_rng().gen_range(0, N_SYMS);
        let mov = Sym::new(m as u8);
        for _ in 0..1 {
            ms.push(Move::random());
        }
        let mut cp = Cube::new();
        let mut cp2 = Cube::new();
        let mut cp3 = Cube::new();
        for j in 0..ms.len() {
            cp.apply_move(ms.get(j));
            cp2.apply_move(MOVE_MAP[m][ms.get(j).as_idx()]);
        }

        println!("original\n{}", cp);
        println!("remapped moves\n{}", cp2);
        cp.remap_into(mov, &mut cp3);
        println!("moved then remapped\n{}", cp3);

        assert_cubes_eq(&cp2, &cp3);
    }
}

#[derive(Debug, PartialEq, Eq)]
pub enum CanonType {
    NoCanon,
    Canon,
    DoubleCanon,
}

/*
#[test]
pub fn time_bfs_insert_all_positions() {
    timed_bfs(CanonType::NoCanon);
}

#[test]
pub fn time_bfs_insert_canon_positions() {
    timed_bfs(CanonType::Canon);
}

#[test]
pub fn time_bfs_insert_double_canon_positions() {
    timed_bfs(CanonType::DoubleCanon);
}

#[test]
pub fn time_dfs() {
    timed_dfs();
}
*/

pub fn timed_bfs(canon: CanonType) {
    let mut world: HashMap<Cube, i32> = HashMap::new();
    let mut q: Vec<Cube> = Vec::new();
    let mut cp;
    let mut cp2 = Cube::new();
    const MAX_ELEMENTS: usize = 100_000;

    q.push(Cube::new());
    world.insert(Cube::new(), 0);

    let mut qg: usize = 0;
    let mut prevd: i32 = -1;

    while qg < q.len() {
        let d = world[&q[qg]];
        if d != prevd {
            println!("At level {} size {}", d, q.len() - qg);
            if q.len() > MAX_ELEMENTS {
                break;
            }
            prevd = d;
        }
        for i in 0..N_MOVES {
            match canon {
                CanonType::NoCanon => {
                    cp = q[qg].clone();
                    cp.apply_move(Move::new(i as u8));
                    if !world.contains_key(&cp) {
                        world.insert(cp.clone(), d + 1);
                        q.push(cp);
                    }
                }
                CanonType::Canon => {
                    cp = q[qg].clone();
                    cp.apply_move(Move::new(i as u8));
                    cp.canon_into_48(&mut cp2);
                    if !world.contains_key(&cp2) {
                        world.insert(cp2.clone(), d + 1);
                        q.push(cp2.clone());
                    }
                }
                CanonType::DoubleCanon => {
                    cp = q[qg].clone();
                    cp.apply_move(Move::new(i as u8));
                    cp.canon_into_96(&mut cp2);
                    if !world.contains_key(&cp2) {
                        world.insert(cp2.clone(), d + 1);
                        q.push(cp2.clone());
                    }
                    cp = q[qg].clone();
                    cp.apply_sp_move(Move::new(i as u8));
                    cp.canon_into_96(&mut cp2);
                    if !world.contains_key(&cp2) {
                        world.insert(cp2.clone(), d + 1);
                        q.push(cp2.clone());
                    }
                }
            }
        }
        qg += 1;
    }
}

pub fn dfs(cp: &Cube, to_go_init: u32, canon_state: u64, a: &mut Vec<Cube>) {
    a.push(cp.clone());
    let mut to_go = to_go_init;
    if to_go > 0 {
        let mut cp2;
        to_go -= 1;
        let mask: u64 = canon_seq_mask(canon_state);
        for mv in 0..N_MOVES {
            if (mask >> mv) & 1 != 0 {
                cp2 = cp.clone();
                cp2.apply_move(Move::new(mv as u8));
                dfs(&cp2, to_go, next_canon_seq(canon_state, mv) as u64, a);
            }
        }
    }
}

pub fn timed_dfs() {
    let mut q: Vec<Cube> = Vec::new();
    const MAX_ELEMENTS: usize = 30_000_000;

    let mut prev_count: u64 = 0;
    let mut d = 0;
    loop {
        q.clear();

        dfs(&Cube::new(), d, CANON_SEQ_START, &mut q);

        q.sort();
        let n_total = q.len();
        q.dedup();
        let n_uniq = q.len();
        println!(
            "at level {} seqs {} posns {} size {}",
            d,
            n_total,
            n_uniq,
            n_uniq as u64 - prev_count
        );
        prev_count = n_uniq as u64;
        if n_uniq > MAX_ELEMENTS {
            break;
        }

        d += 1;
    }
}

// Display impls

impl fmt::Display for EdgePerm {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:3?}", self.to_cubie())
    }
}

impl fmt::Display for Edge {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // write!(f, "{}:{}", self.perm(), self.orient().0)
        if self.0 == INVALID {
            write!(f, "invalid")
        } else {
            write!(f, "[{:2x} {} {:2?}]", self.0, self.perm(), self.orient().0)
        }
    }
}

impl fmt::Display for CornPerm {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:3?}", self.to_cubie())
    }
}

impl fmt::Display for Corn {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.0 == INVALID {
            write!(f, "invalid")
        } else {
            write!(f, "[{:2x} {} {:1?}]", self.0, self.perm(), self.orient().0)
        }
    }
}

impl fmt::Display for Cube {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, " edges ")?;
        for e in &self.edges {
            write!(f, "{}", e)?;
        }
        write!(f, " corns ")?;
        for c in &self.corns {
            write!(f, "{}", c)?;
        }
        Ok(())
    }
}

impl fmt::Display for Move {
    // corrective y rotation
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let face = match self.0 / 3 {
            0 => MoveFace::U,
            // 1 => MoveFace::F,
            1 => MoveFace::L,
            // 2 => MoveFace::R,
            2 => MoveFace::F,
            3 => MoveFace::D,
            // 4 => MoveFace::B,
            4 => MoveFace::R,
            // 5 => MoveFace::L,
            5 => MoveFace::B,
            6 => MoveFace::I,
            7 => MoveFace::J,
            8 => MoveFace::K,
            _ => unreachable!(),
        };
        let suffix = match self.0 % 3 {
            0 => " ",
            1 => "2",
            2 => "'",
            _ => unreachable!(),
        };
        write!(f, "{:?}{}", face, suffix)
    }
}


#[derive(Debug, Clone)]
struct PruneNode {
    depth: Depth,
    // good_moves: Vec<Move>,
    state: Cube,
    submodel: Submodel,
}

pub type Depth = u32;
pub type Submodel = u64;
pub type PruneTable = ::std::collections::HashMap<Submodel, Depth>;

pub fn generate_prune_table(get_submodel: impl Fn(&Cube) -> Submodel) -> PruneTable {
    let max_depth = 999;
    let max_nodes = 1_000_000;
    let mut c = Cube::new();
    let mut depth = 1;
    let mut prunetbl: PruneTable = HashMap::new();

    let mut frontier = Vec::<PruneNode>::new();
    // let mut frontier_size = 1;

    let mut iter_nodes_visited;
    let mut iter_nodes_found;

    let submodel = get_submodel(&c);
    let goal_submodel = submodel;
    println!("goal: {:064b}", submodel);
    println!("goal: {}", submodel);

    frontier.push(PruneNode {
        depth: 0,
        // good_moves: Vec::new(),
        state: c.clone(),
        submodel,
    });
    prunetbl.insert(goal_submodel, 0); // or 1?

    while !frontier.is_empty() {
        if depth > max_depth {
            break;
        }

        iter_nodes_found = 0;
        iter_nodes_visited = 0;

        let iter_frontier = frontier.drain(..).collect::<Vec<_>>();

        for PruneNode {
            state: cur_state,
            ..
        } in iter_frontier.iter()
        {

            for raw_mov in 0..(N_MOVES - 9) as u8 {
                c = cur_state.clone();
                let mov = Move::new(raw_mov);

                c.apply_move(mov);
                let submodel = get_submodel(&c);
                if !prunetbl.contains_key(&submodel) {
                    frontier.push(PruneNode {
                        depth: depth + 1,
                        // path_from_goal: path.clone(),
                        state: c.clone(),
                        submodel,
                    });
                    iter_nodes_found += 1;
                }
            }

            iter_nodes_visited += 1;
        }
        prunetbl.extend(
            frontier
                .iter()
                .cloned()
                .map(|node| (node.submodel, node.depth)),
        );
        println!(
            "prunetbl nodes: {}, frontier size: {}, nodes visited: {}, nodes found: {}",
            prunetbl.len(),
            frontier.len(),
            iter_nodes_visited,
            iter_nodes_found,
        );

        if prunetbl.len() > max_nodes {
            break;
        }

        depth += 1;
    }
    prunetbl
}
